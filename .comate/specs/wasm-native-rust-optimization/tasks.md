# Wasm-Native Rust 优化项目任务规划

## 概述

基于 Architecture 2.0 的混合设计策略，本任务规划将 WasmRust 从"为 WASM 优化的 Rust"转变为"从 MoonBit 学习的混合系统语言"。项目通过 18 个月的分阶段实施，实现 MoonBit 级别的性能同时保持 Rust 的生态系统优势。

**核心目标**: 成为 Rust 开发者的"MoonBit 路径"，在保持所有使 Rust 成为系统编程首选特性的同时，提供竞争性能和现代 WASM 特性。

**总时间线**: 21 个月，平均 3.8 FTE，约 $1.5M 预算

## 阶段 0: Architecture 2.0 重构和基础建设

- [ ] 0.1 重新定位 WasmRust 为混合系统语言
  - 更新项目文档和 README.md，强调"系统的原生 Rust，WASM 的 GC Rust"定位
  - 创建 docs/architecture/wasmrust-vs-moonbit.md，详细对比 Architecture 2.0 优势
  - 建立 Architecture 2.0 设计原则和决策文档
  - 更新项目结构以支持双重编译模式
  - _时间估计: 2 周_
  - _需求: 项目重新定位，Architecture 2.0 设计_

- [ ] 0.2 实现条件编译基础设施
  - 添加 `#[wasm::gc]` 属性解析器
  - 实现条件编译系统，支持目标特定类型别名
  - 建立双重 lowering 策略的基础设施
  - _时间估计: 3 周_
  - _需求: Architecture 2.0 混合编译支持_

- [ ] 0.3 创建 GC 运行时基础设施
  - 实现基础的 WasmGC 类型系统 (`GcArray<T>`, `GcString`, `GcBox<T>`)
  - 建立与主机 GC 的集成接口
  - 创建 GC 类型与所有权类型的转换函数
  - _时间估计: 4 周_
  - _需求: GC 类型系统基础_

- [ ] 0.4 建立策展注册表原型
  - 创建 `wasm-crates.io` 注册表基础设施
  - 实现自动化 WASM 兼容性测试
  - 建立分叉 crate 的同步机制
  - _时间估计: 3 周_
  - _需求: 策展生态系统基础设施_

### 检查点 0: Architecture 2.0 基础验证
- ✅ Architecture 2.0 设计文档完成
- ✅ 条件编译基础设施工作
- ✅ GC 类型系统基础实现
- ✅ 策展注册表原型可用
- **性能目标**: GC hello world <2KB
- **兼容性目标**: 现有 Rust 代码在原生模式下无修改工作

## 阶段 1: GC 运行时完整实现

- [ ] 1.1 完整实现 GC 类型系统
  - 实现 `GcArray<T>` 的完整 API（迭代、映射、过滤等）
  - 实现 `GcString` 的字符串操作 API
  - 实现 `GcBox<T>` 和 `GcRc<T>` 引用类型
  - 添加 GC 类型间的零拷贝操作支持
  - _时间估计: 5 周_
  - _需求: GC 类型完整实现_

- [ ] 1.2 集成 WasmGC 语义
  - 与主机 WasmGC 运行时深度集成
  - 实现跨语言循环收集支持
  - 添加 GC 压力和提示机制
  - 实现 GC 安全的内存布局
  - _时间估计: 4 周_
  - _需求: WasmGC 语义集成_

- [ ] 1.3 实现 GC 与所有权类型转换
  - 高效的 `GcArray<T> ↔ Vec<T>` 转换
  - 实现 `GcString ↔ String` 零拷贝转换
  - 添加转换成本分析和优化建议
  - 实现批量转换优化
  - _时间估计: 3 周_
  - _需求: 类型转换优化_

- [ ] 1.4 添加 GC 性能分析工具
  - GC 分配和释放性能监控
  - 内存泄漏检测和报告
  - GC 暂停时间分析
  - 性能基准测试套件
  - _时间估计: 2 周_
  - _需求: GC 性能监控_

### 检查点 1: GC 运行时验证
- ✅ 完整 GC 类型系统实现
- ✅ WasmGC 语义集成完成
- ✅ 高效类型转换实现
- ✅ GC 性能分析工具可用
- **性能目标**: GC 操作比所有权模式快 20%+
- **内存目标**: GC 模式零内存泄漏

## 阶段 2: 原生异步实现

- [ ] 2.1 实现 `#[wasm::async]` 属性系统
  - 扩展 rustc 以识别 `#[wasm::async]` 属性
  - 实现异步函数的 MIR 转换
  - 添加组件模型异步 lowering 支持
  - 创建异步函数的调试支持
  - _时间估计: 4 周_
  - _需求: 原生异步属性_

- [ ] 2.2 实现 WASM suspending 函数生成
  - 将 Rust async/await 直接降低到 WASM suspending 函数
  - 实现与宿主 promise 的直接集成
  - 添加异步状态机优化（仅在需要时）
  - 支持异步函数的导出和导入
  - _时间估计: 5 周_
  - _需求: suspending 函数生成_

- [ ] 2.3 集成宿主异步运行时
  - 浏览器 promise 集成
  - Node.js async/await 集成
  - Wasmtime 异步支持
  - 跨主机异步统一抽象
  - _时间估计: 3 周_
  - _需求: 宿主异步集成_

- [ ] 2.4 优化异步性能
  - 异步函数零开销抽象
  - 异步堆栈优化
  - 异步内存使用优化
  - 异步热路径优化
  - _时间估计: 2 周_
  - _需求: 异步性能优化_

### 检查点 2: 原生异步验证
- ✅ `#[wasm::async]` 系统工作正常
- ✅ suspending 函数生成正确
- ✅ 宿主异步集成完成
- ✅ 异步性能达到目标
- **性能目标**: 异步操作零开销（相比 futures）
- **兼容性目标**: 所有主流宿主支持

## 阶段 3: 自动 WIT 生成

- [ ] 3.1 实现 `#[wasm::component]` 宏系统
  - 组件属性解析和处理
  - Rust 类型到 WIT 类型的自动映射
  - 组件接口自动生成
  - 组件导出和导入的统一处理
  - _时间估计: 4 周_
  - _需求: 组件宏系统_

- [ ] 3.2 实现类型到 WIT 映射
  - `GcArray<T>` → `list<T>` 映射
  - `GcString` → `string` 映射
  - `GcBox<T>` → `(ref $T)` 映射
  - 复杂类型的递归映射
  - 自定义类型的映射规则
  - _时间估计: 3 周_
  - _需求: 类型-WIT 映射_

- [ ] 3.3 实现 WIT 代码生成
  - 自动 .wit 文件生成
  - TypeScript 绑定生成
  - 其他语言绑定生成（Python, Go 等）
  - WIT 验证和测试
  - _时间估计: 3 周_
  - _需求: WIT 代码生成_

- [ ] 3.4 集成组件模型运行时
  - WIT 运行时支持
  - 组件动态加载和链接
  - 组件版本兼容性检查
  - 组件安全验证
  - _时间估计: 2 周_
  - _需求: 组件运行时集成_

### 检查点 3: 自动 WIT 生成验证
- ✅ 组件宏系统完整
- ✅ 类型-WIT 映射正确
- ✅ WIT 代码生成工作正常
- ✅ 组件运行时集成完成
- **功能目标**: 90% 用例无需手动 WIT
- **兼容性目标**: 生成 WIT 100% 符合标准

## 阶段 4: 流式编译优化

- [ ] 4.1 实现 `#[wasm::profile(streaming)]` 配置
  - 流式配置文件解析
  - 瘦单态化算法增强
  - 函数依赖图构建
  - 流式布局优化算法
  - _时间估计: 3 周_
  - _需求: 流式配置文件_

- [ ] 4.2 增强瘦单态化
  - GC 模式的单态化优化
  - 跨函数共享实现识别
  - 泛型特化代码减少算法
  - 单态化性能分析
  - _时间估计: 4 周_
  - _需求: 增强单态化_

- [ ] 4.3 实现有序函数发射
  - 函数依赖分析和排序
  - 导出存根生成优化
  - 热路径函数识别和优先处理
  - 冷代码延迟策略
  - _时间估计: 3 周_
  - _需求: 有序函数发射_

- [ ] 4.4 优化 WASM 模块布局
  - 流式下载优化布局
  - instantiateStreaming 兼容性
  - 模块压缩和优化
  - 启动时间分析工具
  - _时间估计: 2 周_
  - _需求: 模块布局优化_

### 检查点 4: 流式编译验证
- ✅ 流式配置文件实现完成
- ✅ 瘦单态化达到 50%+ 代码减少
- ✅ 有序函数发射工作正常
- ✅ 模块布局优化有效
- **性能目标**: Hello world <1.5KB，启动 <1ms
- **质量目标**: 100% 流式兼容性

## 阶段 5: 编译器集成和优化

- [ ] 5.1 集成双重 lowering 到 rustc
  - 扩展 rustc 编译器管道
  - 条件编译和目标选择集成
  - MIR 到双重代码生成
  - 编译器优化集成
  - _时间估计: 5 周_
  - _需求: 编译器双重 lowering_

- [ ] 5.2 实现 GC 模式的借用检查禁用
  - GC 模式的借用检查控制
  - GC 安全性验证
  - 混合模式的边界检查
  - 错误报告和诊断改进
  - _时间估计: 3 周_
  - _需求: GC 模式编译器集成_

- [ ] 5.3 优化编译器性能
  - GC 模式编译加速（跳过借用检查）
  - 增量编译支持
  - 并行编译优化
  - 编译缓存改进
  - _时间估计: 3 周_
  - _需求: 编译器性能优化_

- [ ] 5.4 实现开发者工具集成
  - IDE 集成（rust-analyzer 支持）
  - 调试工具适配
  - 性能分析工具
  - 错误诊断增强
  - _时间估计: 2 周_
  - _需求: 开发者工具集成_

### 检查点 5: 编译器集成验证
- ✅ 双重 lowering 完全集成
- ✅ GC 模式编译速度提升 3x+
- ✅ 编译器优化有效
- ✅ 开发者工具集成完成
- **性能目标**: 10k LOC <2s 编译时间
- **兼容性目标**: 现有代码 100% 兼容

## 阶段 6: 策展生态系统建设

- [ ] 6.1 扩展 wasm-crates.io 注册表
  - 自动化 crate 分叉和适配
  - 兼容性测试自动化
  - 版本同步机制
  - 社区贡献工具
  - _时间估计: 4 周_
  - _需求: 策展注册表扩展_

- [ ] 6.2 适配核心 crates
  - 适配前 100 个最流行 crates
  - GC 模式优化版本
  - 性能基准测试
  - 迁移指南和工具
  - _时间估计: 6 周_
  - _需求: 核心 crates 适配_

- [ ] 6.3 实现自动迁移工具
  - wasm-bindgen 到 GC 模式迁移
  - 自动兼容性检查
  - 迁移成本分析
  - 渐进式迁移支持
  - _时间估计: 3 周_
  - _需求: 自动迁移工具_

- [ ] 6.4 建立社区生态
  - 文档和教程
  - 示例项目
  - 社区支持和反馈机制
  - 贡献者指南
  - _时间估计: 2 周_
  - _需求: 社区生态建设_

### 检查点 6: 生态系统验证
- ✅ 策展注册表包含 70%+ 流行 crates
- ✅ 核心 crates 适配完成
- ✅ 迁移工具有效
- ✅ 社区生态活跃
- **覆盖目标**: 70% 流行 crates 可用
- **质量目标**: 100% 兼容性保证

## 阶段 7: 测试、验证和文档

- [ ] 7.1 完整测试套件
  - 单元测试覆盖
  - 集成测试
  - 性能回归测试
  - 兼容性测试
  - _时间估计: 3 周_
  - _需求: 完整测试覆盖_

- [ ] 7.2 性能基准测试
  - MoonBit 对比基准
  - 多目标性能测试
  - 内存使用分析
  - 启动时间测试
  - _时间估计: 2 周_
  - _需求: 性能基准测试_

- [ ] 7.3 文档和教程
  - Architecture 2.0 指南
  - 迁移教程
  - 最佳实践指南
  - API 参考文档
  - _时间估计: 2 周_
  - _需求: 完整文档_

- [ ] 7.4 生产就绪验证
  - 生产环境测试
  - 安全审计
  - 性能验证
  - 发布准备
  - _时间估计: 2 周_
  - _需求: 生产就绪验证_

### 最终检查点: 生产发布
- ✅ 所有 Architecture 2.0 功能完整实现
- ✅ 性能达到 MoonBit 级别
- ✅ 生态系统建设完成
- ✅ 文档和测试完整
- **最终性能目标**: Hello world <1.5KB，启动 <1ms，编译 <2s
- **生态系统目标**: 70%+ crates 兼容性

## 关键里程碑和验证标准

### 里程碑 1: GC 运行时完成 (阶段 1 后)
- **必须通过**:
  - ✅ GC 类型系统完整实现
  - ✅ WasmGC 语义集成
  - ✅ 与所有权类型高效转换
  - ✅ GC 性能监控工具
- **性能门控**:
  - GC 操作性能 >所有权模式 20%+
  - 内存使用 <所有权模式 50%
  - 零内存泄漏

### 里程碑 2: 原生异步完成 (阶段 2 后)
- **必须通过**:
  - ✅ `#[wasm::async]` 系统工作
  - ✅ suspending 函数生成正确
  - ✅ 宿主异步集成完成
  - ✅ 异步零开销实现
- **性能门控**:
  - 异步操作开销 = 0（相比 futures）
  - 宿主 promise 集成 <10ns 延迟
  - 所有主流宿主支持

### 里程碑 3: 自动 WIT 完成 (阶段 3 后)
- **必须通过**:
  - ✅ 组件宏系统完整
  - ✅ 类型-WIT 映射正确
  - ✅ WIT 代码生成工作
  - ✅ 组件运行时集成
- **功能门控**:
  - 90% 用例无需手动 WIT
  - 生成 WIT 100% 符合标准
  - 组件模型完全支持

### 里程碑 4: 流式编译完成 (阶段 4 后)
- **必须通过**:
  - ✅ 流式配置文件实现
  - ✅ 瘦单态化达到 50%+ 代码减少
  - ✅ 有序函数发射工作
  - ✅ 模块布局优化有效
- **性能门控**:
  - Hello world <1.5KB
  - 启动 <1ms
  - 100% 流式兼容性

### 最终里程碑: Architecture 2.0 完成 (阶段 7 后)
- **必须通过**:
  - ✅ 所有功能完整实现
  - ✅ 性能达到 MoonBit 级别
  - ✅ 生态系统建设完成
  - ✅ 生产环境验证通过
- **最终目标**:
  - Hello world <1.5KB（vs MoonBit ~10KB）
  - 启动 <1ms（vs MoonBit <1ms）
  - 编译 <2s for 10k LOC（vs MoonBit <1s）
  - 70%+ crates 兼容性（vs MoonBit 100% 小生态）

## 资源分配

### 团队配置
- **项目经理** (1.0 FTE): 整体协调、里程碑管理
- **编译器工程师** (1.5 FTE): GC 运行时、异步支持、编译器集成
- **系统工程师** (1.0 FTE): 流式编译、性能优化、工具集成
- **生态工程师** (0.5 FTE): 策展注册表、crate 适配、社区建设
- **测试工程师** (0.5 FTE): 测试套件、性能基准、质量保证

**总计**: 4.5 FTE（高于原计划的 3.1 FTE，反映 Architecture 2.0 的复杂性）

### 预算分配
- **人员成本**: 4.5 FTE × $150k × 1.5 年 = $1,012,500
- **基础设施**: $50,000（CI/CD、注册表托管、性能测试）
- **生态系统建设**: $30,000（crate 适配、社区支持）
- **安全审计**: $40,000（第三方安全审计）
- **应急缓冲**: $167,500（15% 缓冲）

**总预算**: ~$1.3M USD

## 风险缓解策略

### 技术风险
1. **Architecture 2.0 复杂性**: 分阶段实施，每阶段独立验证
2. **GC 集成挑战**: 早期原型验证，渐进式集成
3. **性能目标**: 持续性能监控，早期性能门控
4. **兼容性问题**: 广泛测试，向后兼容性保证

### 资源风险
1. **人才获取**: 提前招聘，知识转移计划
2. **预算超支**: 阶段性预算审查，范围灵活性
3. **时间压力**: 关键路径优先，非核心功能延后

### 市场风险
1. **MoonBit 演进**: 持续竞争分析，快速响应
2. **WasmGC 标准化**: 积极参与标准制定，多方案准备
3. **Rust 生态系统变化**: 与 Rust 团队密切合作，兼容性维护

## 成功指标

### 开发者体验指标
- **学习曲线**: 新手完成教程时间 <2 小时
- **迁移成本**: 现有项目迁移时间 <1 天
- **开发效率**: 相比标准 Rust 开发速度提升 2x+
- **错误率**: 编译错误减少 50%+

### 性能指标
- **二进制大小**: 相比标准 Rust 减少 60%+
- **启动时间**: 相比标准 Rust 提升 5x+
- **运行时性能**: GC 模式性能 ≥所有权模式
- **内存使用**: GC 模式内存使用 ≤所有权模式

### 生态系统指标
- **crate 覆盖**: 前 100 crates 70%+ 支持
- **社区活跃度**: 月活跃贡献者 >50
- **采用率**: 6 个月内 >1000 项目使用
- **文档质量**: 文档完整度 >90%

### 战略指标
- **MoonBit 竞争**: 80% 指标达到或超越 MoonBit
- **Rust 生态兼容**: 95% 现有代码无需修改工作
- **技术创新**: Architecture 2.0 成为行业参考
- **社区影响**: 成为 WASM 开发首选 Rust 方案

通过这个全面的任务规划，WasmRust Architecture 2.0 将成功实现其雄心勃勃的目标，成为连接 Rust 和 WebAssembly 的桥梁，为开发者提供两全其美的解决方案。
