# Architecture 2.0 设计原则和决策

## 概述

本文档定义了WasmRust Architecture 2.0的核心设计原则、技术决策和架构规范。Architecture 2.0代表了从"Rust到WASM编译器"到"混合系统语言"的战略转型。

## 核心理念

> **"Native Rust for systems. GC-ready Rust for WebAssembly."**

### 双重身份设计
- **身份1**: 完整兼容的标准Rust，面向原生系统目标
- **身份2**: GC就绪的Rust变体，面向WebAssembly目标
- **切换机制**: 编译时条件性质，而非运行时动态切换

## 设计原则

### 1. 最小侵入性原则
- **目标**: 现有Rust代码无需修改即可编译运行
- **方法**: 通过属性注解和类型别名实现条件编译
- **验证**: 保证原生和WASM目标的语义等价性

### 2. 编译时确定性原则
- **目标**: 编译时明确所有语义决策
- **方法**: `#[wasm::gc]`属性在编译时确定GC语义
- **益处**: 消除运行时不确定性，优化代码生成

### 3. 生态系统兼容性原则
- **承诺**: 100%向后兼容现有Rust生态系统
- **策略**: 渐进式功能启用，而非破坏性变更
- **验证**: 自动化兼容性测试套件

### 4. 性能可预测性原则
- **目标**: 明确的性能特征和优化路径
- **方法**: 双重编译策略（Cranelift + LLVM）
- **指标**: 可衡量的性能基准和优化目标

## 架构决策

### 决策1: 条件编译而非语言分叉

**问题**: 如何处理GC语义和WASM特定优化？

**选项评估**:
- **语言分叉**: 创建Rust-WASM变体（高成本，生态系统分裂）
- **运行时切换**: 动态GC启用（性能开销，复杂性）
- **条件编译**: 编译时GC语义选择（选定方案）

**决策理由**:
- 保持单一代码库，减少维护负担
- 编译时优化，无运行时开销
- 渐进式采用，降低迁移风险

### 决策2: 属性驱动而非配置驱动

**问题**: 如何标记GC就绪的代码区域？

**选项评估**:
- **配置文件**: 外部配置指定GC区域（灵活性低）
- **命令行参数**: 编译参数控制（容易出错）
- **属性注解**: 代码内语义标记（选定方案）

**决策理由**:
- 代码自描述，明确语义意图
- IDE友好，工具链集成度高
- 重构安全，语义跟随代码移动

### 决策3: 双重编译策略

**问题**: 如何平衡开发速度和运行时性能？

**选项评估**:
- **单一后端**: 简化但无法优化（性能损失）
- **插件系统**: 灵活但复杂（维护负担）
- **双重编译**: 开发+发布模式（选定方案）

**决策理由**:
- Cranelift: 快速迭代，开发友好
- LLVM: 极致优化，生产就绪
- 明确的使用场景和性能预期

## 技术规范

### GC类型系统规范

#### 基本GC类型
```rust
// GC就绪的字符串类型
#[wasm::gc]
struct GcString {
    data: Vec<u8>,  // 在WASM目标中变为GC管理
}

// GC数组类型
#[wasm::gc]
struct GcArray<T> {
    elements: Vec<T>,  // WASM目标中GC管理
}
```

#### 类型转换规则
- **自动转换**: GC类型到所有权类型的隐式转换
- **显式转换**: 所有权类型到GC类型的显式操作
- **边界检查**: 编译时验证转换安全性

### 编译开关规范

#### #[wasm::gc]属性
```rust
#[wasm::gc]  // 仅WASM目标生效
struct ManagedData {
    // 在WASM目标中使用GC语义
    // 在原生目标中使用标准语义
}
```

#### 条件编译宏
```rust
#[cfg(target_family = "wasm")]
use wasm::gc_types::GcString;

#[cfg(not(target_family = "wasm"))]
use std::string::String as GcString;
```

### 语义边界规范

#### 确定性语义
- **保证**: 带GC注解的代码在原生目标中行为不变
- **验证**: 自动化语义等价性测试
- **文档**: 明确的语义边界文档

#### 优化边界
- **GC区域**: 明确标记的可优化区域
- **非GC区域**: 保持标准Rust语义
- **边界检查**: 编译时验证优化安全性

## 实施指南

### 阶段1: 基础架构
1. 实现条件编译基础设施
2. 建立GC类型系统原型
3. 创建语义验证工具

### 阶段2: 功能完善
1. 完善GC运行时集成
2. 优化双重编译策略
3. 建立性能基准

### 阶段3: 生产就绪
1. 稳定性验证
2. 生态系统集成
3. 文档和工具完善

## 风险评估和缓解

### 技术风险
- **复杂性风险**: 通过清晰的架构边界缓解
- **性能风险**: 通过双重编译策略管理
- **兼容性风险**: 通过自动化测试保障

### 采用风险
- **学习曲线**: 通过渐进式文档和示例缓解
- **工具支持**: 通过IDE插件和工具链集成改善
- **生态系统**: 通过兼容性保证降低风险

## 总结

Architecture 2.0代表了WasmRust的成熟和专业化发展。通过明确的设计原则、经过严谨评估的架构决策和详细的技术规范，我们建立了可持续、可演进的技术基础。

核心价值主张: **在不牺牲Rust生态系统兼容性的前提下，为WebAssembly目标提供GC就绪的优化路径。**